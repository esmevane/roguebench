# Command Bus Framework

Central message routing system for game events that sit above raw input.

## Relationship to Lightyear

Lightyear handles low-level networking concerns:
- **Input replication**: Player inputs (movement direction, button presses) flow through Lightyear's input protocol
- **Component replication**: Position, Velocity, and other components sync automatically via `Replicate`
- **Tick synchronization**: Fixed timestep execution happens in `FixedMain` schedule

The command bus handles **game-level events** that aren't raw input:
- Damage application
- Entity spawns and despawns
- Quest/narrative triggers
- Effect application (buffs, debuffs)
- Editor/content operations

```
┌─────────────────────────────────────────────────────────────┐
│  Player Input                                               │
│  (movement, aim, buttons)                                   │
└─────────────────────────────────────────────────────────────┘
                              ↓
              Lightyear Input Protocol (tick-synced)
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  Physics / Movement Systems                                 │
│  (Avian processes velocity, collisions)                     │
└─────────────────────────────────────────────────────────────┘
                              ↓
              Game Events (collisions, triggers, timers)
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  Command Bus                                                │
│  (damage, spawns, quests, effects)                          │
└─────────────────────────────────────────────────────────────┘
```

## Core Logic

**Concept**

- Game-level mutations flow through commands
- Commands are serializable and replayable
- Enables scripting hooks, persistence, and debugging
- Decouples intent from execution

**Command Categories**

| Category | Persistence | Examples |
|----------|-------------|----------|
| Persistent | Must replay for state reconstruction | Damage, Death, Spawn, QuestUpdate |
| Ephemeral | Can be dropped without corruption | ParticleSpawn, SoundTrigger, ScreenShake |

Persistent commands are logged and can be replayed. Ephemeral commands execute immediately and aren't stored.

**Command Properties**

| Property | Type | Description |
|----------|------|-------------|
| id | string | Command type identifier |
| payload | data | Command-specific data |
| source | enum | System, Script, Editor |
| tick | u64 | Game tick when issued |
| persistent | bool | Whether to log for replay |

**Command Flow**

```
Event → Command → Validation → Execution → Hooks
                      ↓              ↓
                   Reject      Script Callbacks
```

**Operations**

`send(command)` - Queue command for processing

- Validate command against current world state
- Add to queue
- Process in tick order

`register_handler(command_type, handler)` - Register processor

- Map command type to handler function
- Handler executes command and returns result

`add_hook(command_type, hook)` - Add script hook

- Pre/post execution callbacks
- For scripting and debugging integration

`replay(commands)` - Execute command sequence

- For save/load state reconstruction
- For debugging (replay session)

**Invariants**

- Commands processed in deterministic tick order
- Same commands at same tick produce same results
- Failed commands don't mutate state
- Persistent commands logged; ephemeral commands not logged

**What Commands Are NOT For**

- Raw player input (use Lightyear input protocol)
- Movement/velocity changes (use Avian physics)
- Component replication (use Lightyear `Replicate`)
- Per-frame updates (use normal Bevy systems)

---

## Bevy Integration

**Resources**

```rust
struct CommandBus {
    queue: VecDeque<CommandEnvelope>,
    handlers: HashMap<TypeId, Box<dyn CommandHandler>>,
}

struct CommandLog {
    persistent_commands: Vec<CommandEnvelope>,
}
```

**Traits**

```rust
trait GameCommand: Send + Sync + Clone + Serialize + DeserializeOwned {
    /// Unique identifier for this command type
    fn command_id() -> &'static str;
    
    /// Whether this command must be logged for state reconstruction
    fn is_persistent() -> bool;
    
    /// Validate against current world state
    fn validate(&self, world: &World) -> Result<(), CommandError>;
    
    /// Execute the command, mutating world state
    fn execute(&self, world: &mut World) -> CommandResult;
}
```

**Command Envelope**

```rust
struct CommandEnvelope {
    command_id: &'static str,
    payload: Box<dyn ErasedCommand>,
    source: CommandSource,
    tick: u64,
}

enum CommandSource {
    System,    // Generated by game systems (collision → damage)
    Script,    // Generated by scripting layer
    Editor,    // Generated by content editor
}
```

**Systems**

- `process_command_queue` - Runs in `FixedMain`, processes queued commands in order
- `log_persistent_commands` - Appends persistent commands to log after execution
- `emit_command_events` - Fires Bevy events for external observation

**Events**

```rust
struct CommandExecuted<C: GameCommand> {
    command: C,
    result: CommandResult,
}

struct CommandRejected {
    command_id: &'static str,
    reason: CommandError,
}
```

---

## Example Commands

**Persistent (logged for replay):**

```rust
struct ApplyDamage {
    target: Entity,  // Bevy entity (resolved at execution time)
    amount: i32,
    source: Option<Entity>,
}

impl GameCommand for ApplyDamage {
    fn is_persistent() -> bool { true }
    // ...
}
```

**Ephemeral (fire and forget):**

```rust
struct SpawnParticle {
    position: Vec2,
    effect_id: String,
}

impl GameCommand for SpawnParticle {
    fn is_persistent() -> bool { false }
    // ...
}
```

---

## Server vs Client Execution

Commands execute on **server only** by default. The server's authoritative state replicates to clients via Lightyear.

For client-side effects (particles, sounds, screen shake):
- Server sends ephemeral commands via Lightyear message channel
- Client command bus processes them locally
- No validation needed (server already validated the trigger)

```
Server: Collision detected → ApplyDamage command → Health reduced → Replicated
        ↓
        SpawnParticle message → Lightyear → Client
        ↓
Client: Receives message → Local particle spawn
```

---

## Scripting Integration

Scripts can:
- Emit commands (with `Script` source)
- Hook command execution (pre/post callbacks)
- Query command log for debugging

Scripts cannot:
- Bypass validation
- Execute commands directly (must go through bus)
- Modify persistent command log

---

## Debugging

The command log enables:
- Session replay (re-execute all persistent commands)
- Time travel debugging (replay up to tick N)
- State inspection (what commands led to this state?)

---

## What's Deferred

- Undo/redo for editor (needs inverse command design)
- Command batching for network efficiency
- Command prioritization

*See: architecture/scripting.md, architecture/protocol.md*
